# 내용정리

---

- 객체의 생명주기는 new 연산자를 호출할 때 시작해서, 그 누구도 객체를 필요로 하지 않는 시점에 종료한다.
- 살아있는 시간 동안 객체는 맡은 일을 처리하며, 그 과정에서 예외 처리가 있을 수 있음
- 그러나, 부정확한 방식으로 예외처리 되는 것을 방지해야 함

<br />

- 메서드를 호출할 때마다 null 이 반환될 수 있는 가능성이 객체에 대한 신뢰를 무너뜨린다.
- 에러 상황이나, 예외 처리가 필요한 상황이면 null 을 반환하는 것이 아닌 예외처리하는 것이 맞다.

<br />

- 빠르게 실패하기 
  - 문제가 발생하면 곧바로 실행을 중단시킴
  - 실패를 분명하게 만드는 것을 권장
- 안전하게 실패하기
  - 안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등 문제가 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 권장
  - IOException 을 처리하는 것보다 다른 누군가가 이 문제를 해결하기를 기대함
  - 그러나 Null Point Exception 이 언제든 발생할 수 있다는 것이 내포되어 있음


<br />

- Null 을 반환하지 않는 다른 방법
  - null 대신 boolean 값을 반환시키는 로직
  - new ArrayList<>(0); 와 같은 빈 배열을 반환
  - Optional.empty() 같은 것을 반환

- Null 대신 예외를 던지거나, 컬렉션을 반환하거나, 널 객체를 반환하라.


<br /><br />

# 느낀점 

---

- Null 을 반환할 때의 문제점을 명확히 알 수 있는 파트였다.
- 책에서 제시했듯이, 우리는 찾고자 하는 객체가 없으면 Null 을 반환하는 로직을 많이 쓴다.
- 그러나 위처럼 Null 을 반환하는 순간, 에러가 내포되어있는 것이며, 어디서 에러가 날지 우리는 예측하지 못한다.
- 나도 업무에서, Null Point Exception 이 날 때, 해당 객체가 어느 지점에서 null 이 되는지를 찾아본 경험이 있다.
  - 이는 불변객체, null 반환 금지 등의 디자인으로 충분히 예방될 수 있다.
- 안전하게 실패하기 보다는 빠르게 실패하기가 훨씬 낫다.
- 안전한 상태에서 Product 으로 올라가면, 우리는 다음 버전을 배포할 때, Product 에 올라간 서비스 자체를 신뢰할 수 없기 때문이다.
- 이미 Product 에는 올라갔지만 에러가 발생할 수 있는 문제가 야기되있다는 것을 의미한다.
- 책에서 제시한 방법처럼 예외처리나, 빈 컬랙션, null 객체 등을 반환할 수 있는 방향으로 로직을 구성해야겠다.
