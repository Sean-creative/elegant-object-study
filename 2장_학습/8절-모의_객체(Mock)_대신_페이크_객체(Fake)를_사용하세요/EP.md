# 내용 정리

- 테스트를 최적화하기 위한 장치로 모킹(mocking)은 모의객체를 만들어서 객체의 생성자 인자로 사용하고 인자를 만드는 로직을 제외하여 단위테스트를 할 수 있도록 만든다.
- 모킹이 나쁜 프랙티스이며 최후의 수단으로만 사용해야 한다.
- 모킹 대신 ‘페이크 객체(fake object)’를 사용할 것을 제안한다.
- 단위 테스트 안에있는 클래스는 ‘블랙박스(black box)’이기 때문에 어떤 메서드가 호출되는지 알 수 없다.
- 하지만 mock은 불확실한 가정을 세우고 이 가정을 중심으로 테스트를 구축한다. 또한 코드를 통해 이것이 우리가 이 객체의 작동 방식에 대해 알고 있는 내용이다라고 말을 하는 것과 같다.
- 리팩토링의 안정망이라는 단위 테스트의 전체적인 목적에 벗어난다.
- 만일 mock 방식의 내부 동작이나 생성자 인자가 변경되면 테스트는 다 깨진다. 이런 상황은 단위 테스트에 대한 신뢰를 완전히 무너뜨린다.
- 페이크 객체를 사용하면 단위 테스트가 깨지지 않는다. 모킹은 나쁜 프랙티스이다. 모킹은 단위 테스트를 지원하기 위해 만들어졌지만 단위 테스트에 우호적이지 않다. 모킹은 클래스 구현과 관련된 내부의 세부사항을 테스트와 결합시킨다. 우리는 가정하고 이 가정을 모의 객체 안에 하드코딩하고 작업을 끝낸다. 리팩토링을 할 때 테스트가 유효하지 않은 내부 구현에 결합되어있기 때문에 테스트를 폐기처분하게 된다.
- ‘페이크’ 클래스를 사용하면 충분히 유지보수 가능하게 만들 수 있다. 객체와 객체의 상호작용은 단위 테스트의 관심사가 아니다. 우리에게는 객체의 구현 방법을 알 권리가 없다. 테스트가 객체 내부의 구현 세부사항을 알면 테스트가 취약해지고 유지보수가 어려줘진다. 모킹이 원인이다.  객체와 의존 대상 사이의 상호작용 방식을 확인하거나 테스트하면 안된다. 이것은 객체가 캡슐화해야 하는 정보이다.

# 느낀점

- 회사에서 코드를 작성할 때 MOCK 방식을 자주 사용하는데, 리팩토링을 할 때 항상 테스트코드가 깨지는 것이 문제였다. 또한 나도 의문이었던 것이 슬라이싱 테스트를 할 때 내부 구현 메서드를 가정한다는 점이 꽤나 의문이었다. 캡슐화가 안된다는 느낌을 받았다고 해야 할까.
- 근데 또 하나의 기준이 되었던 것은 테스트 코드를 위해 프로덕션 코드를 추가하는 것을 꺼려했다. 그런데 fake 방식은 인터페이스에서 구현하는 코드를 작성해야 하는 건데, 그 객체를 테스트 환경에서 만들어야할지 의문이다.
