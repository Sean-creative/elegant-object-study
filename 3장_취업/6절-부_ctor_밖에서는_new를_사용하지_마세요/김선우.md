# 간략한 내용정리

@ 의존성 주입
- 의존성 주입이라는 이름을 좋아하지 않으며, 이 기법이 전반적으로 모호하다는 점에서 마음에 들지 않다.

 class Cash {
  private final int dollars;

  public int euro() {
    return new Exchange().rate("USD", "EUR") * tihs.dollars;
  }
}

- 위의 코드의 문제는 '하드코딩된 의존성'이다. Cash 클래스는 Exchange 클래스에 직접 연결되어 있기 때문에, 의존성을 끊기 위해서는 Cash 클래스의 내부 코드를 변경할 수 밖에 없다.
- 큰 규모에서는 하드코딩된 의존성이 소프트웨어를 테스트하고 유지보수하기 어렵게 만든다.
- 이 문제의 근본원인은 new 연산자이다.
- 메서드 내부에서 new 연산자를 사용할 수 없도록 금지하자. -> 그럼 새로운 객체를 ctor의 인자로 받아 private 프로퍼티 안에 캡슐화 할 수 밖에 없다. (ctor 안에서 new + 불변 + 캡슐화)
- 그렇게 되면 의존성을 제어하는 주체가 Cash가 아니라 우리 자신이라는 점에서 차이가 있다.
- 다시말해, 객체가 필요한 의존성을 직접 생성하는 대신, 우리가 ctor를 통해 의존성을 주입한다.
- 이와 같이! 의존성을 주입하는것은 좋은 프랙티스입니다. (의존성 주입 자체가 나쁜게 아니라, 여태까지 잘못된 방식으로 해서 문제였던듯)

@ 더 좋은 의존성 주입을 위한 부 cotr의 추가
- 의존성 주입을 부 ctor에만 할 경우, 주 ctor에서는 객체와 협력하는 모든 의존성을 우리 스스로 완전히 제어할 수 있다.
- 부 ctor를 제외한 어떤 곳에서도 new를 사용할 수 없도록 금지 시킨다면, 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상시킬 수 있다.
- 이 규칙이 의존성 주입과 제어역전에 관해 알아야 하는 전부라고 생각한다.


# 느낀점
- 오랜만에 명확하고 쉽게 동의할 수 있는 챕터였다. 
- 의존성 주입은 책임을 서로 분명하게 가지는 점에서 유지보수가 더 좋아진다고 생각한다.
- 하지만 저자의 말처럼 의존성을 받지 않는 주 ctor를 따로 만들어 놓고, 의존성 주입을 받아야하는 부 ctor를 만든다면 객체들이 상호간에 충분히 분리될 수 있을것 같다.
- 또한 객체를 생성할 때 -> 제어하는 주체가 클래스가 아니라 우리 자신이라는 점이 결합도가 높아지는것을 막을 수 있다.

# 궁금한 점
-

# 찾아봐야 할 것 
- 제어 역전(inversion of control)
