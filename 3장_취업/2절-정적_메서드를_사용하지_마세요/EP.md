# 내용 정리

- 정적 메서드(static method)는 NULL을 도입하는 것 이상으로 커다란 실수다.
- 정적 메서드 대신 객체를 사용해야 한다.

## 객체 대 컴퓨터 사고(object vs computer thinking)

- 우리는 초창기 프로그래밍 언어로부터 컴퓨터처럼 생각하는 방법을 물려받았다.
- 순차적인(sequential) 사고방식을 가리켜 ‘컴퓨터 입장에서 생각하기(thinking as a computer)’라고 부른다.
- 개발자들은 CPU에게 할 일을 지시하는 것이 아니라 정의해야 한다.
- x는 최대값’이다(is a)’라고 정의하는 것이 핵심이다. 함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화 되는 점이 바로 이 ‘is a’이다.
- 컴퓨터처럼 생각하기에는 명령의 실행 흐름을 제어할 책임이 개발자한테 있다.
- 우리는 CPU에게 계산과 관련된 어떤 지시도 내리지않고 단순히 객체를 생성할 뿐이다.
- 하지만 OOP의 정적 메서드는 절차적인 코드를 작성하도록 부추길 뿐이다.

## 선언형 스타일 대 명령형 스타일(declarative vs imperative style)

- 명령형 프로그래밍(imperative programming)에서는 ‘프로그램의 상태를 변경하는 문장(statement)을 사용해서 계산 방식을 서술한다.
- 선언형 프로그래밍(declarative programming)에서는 ‘제어 흐름을 서술하지 않고 계산 로직을 표현’합니다.
    - 엔티티와 엔티티 사이의 관계로 구성되는 자연스러운 사고 패러다임에 가깝다.
    - 제어를 서술하지 않고 로직만 표현한다.
- 오직 하나의 정적 메서드만 호출하는 경우라면 객체를 생성한 뒤 메서드를 호출하는 것 보다 빠르다. 하지만 다수의 정적 메서드를 호출해야하는 경우 필요한 모든 정적 메서드를 순차적으로 호출해야해서  더 느리다.
- OOP에 명령형 스타일보다 선언형 프로그래밍 스타일을 선호하는 이유
    - 실행 관점에서 선언형 방식이 더 최적화된다.
    - 블록 사이의 의존성을 끊을 수 있는 다형성(polymophism)을 사용하기 쉽다.
        - 객체지향에서 객체는 일급 시민(first-clas citizen)이지만 정적 메서드는 그렇지 않다. 정적 메시지는 생성자의 인자로 넘겨줄 수 없다. 객체를 다른 객체로부터 완전히 분리하기 위해서는 메서드나 주생성자 어디에서도 new 연산자를 사용하면 안된다.
    - 선언형 방식은 결과를 이야기하지만 명령형 방식은 수행 가능한 방법을 이야기한다. 코드 안의 루프를 ‘마음 속으로 시각화(visualize)’해야 한다.
        - 알고리즘과 실행 대신 객체와 행동의 관점에서 사고해야한다.
    - 코드의 응집도이다.
        - 코드를 분리할 수 있고, 코드를 연결할 수 있다.
- 기술적으로 명령형 스타일과 선언형 스타일을 조합하는 것은 불가능하다.

## 유틸리티 클래스(Utility classes)

- 클래스가 아니라 편의를 위해 다른 메서들이 사용하는 정적 메서들을 모아 놓은 정적 메서드들의 컬렉션
- 유틸리티 클래스를 구현할 떄는 주생성자를 private으로 만든다.
- 끔찍한 안티패턴이다.

## 싱글톤(Singleton) 패턴

- 싱글톤 패턴은 정적 메서드 대신 사용할 수 있는 유명한 개념이다.
- 싱글톤 안에는 하나의 정적 메서드가 존재하며 일반적인 객체와 거의 유사해 보인다.
- 끔찍한 안티패턴이다.
- 싱글톤과 유틸리티 클래스의 차이
    - 싱글톤은 분리 가능한 의존성으로 연결되어있는데 반해 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다.
    - 싱글톤의 장점은 `getInstance()`와 함께 `setInstance()`를 추가할 수 있는 장점이 있다.
    - 유틸리티 클래스는 분리할 수 없는 하드코딩된 의존성이다.
- 싱글톤은 전역변수 그 이상도 그 이하도 아니다.
- OOP에서는 전역 범위(global scope)가 없다.
- 싱글톤에 대해 생각조차하지 말아라
- 클래스가 작업을 수행하는데 필요한 모든 요소들이 생성자에 제공되고 내부에 캡슐화되어야 한다. 예외도 없다. 객체는 자신이 캡슐화하고 있는 프로퍼티 외에는 어느 것도 건드려서는 안된다.

## 함수형 프로그래밍

- 이 책에서 권장하는 방식에 따라 객체를 ‘우아하게’ 만들었다면 함수와 객체 사이에는 많은 부분이 유사해진다.
- FP보다 OOP의 표현력이 강력하다. OOP에서는 객체와 메서드를 조합할 수 있다.
- 작은 프로시저(micro-procedures)로 동작하는 자바의 메서드가 아니라 하나의 출구(exit point)만 포함하는 순수한 FP 패러다임에 기반하는 진정한 함수를 포함해야 한다.

## 조합 가능한 데코레이터

- 조합 가능한 데코레이타(composable decorator)는 공식적으로 사용되는 명칭이 아니라 책에서 새로 고안한 용어이다.
- 조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체이다. 이것은 유명한 디자인 패턴인 데코레이터(decorator)일 뿐이지만 데코레이터 객체들은 다중계층 구조(multi-layer structures)로 구성하기 시작하면 조합이 가능(composable) 해진다.
- 정적 메서드는 조합이 불가능하다. 정적 메서드는 합성(composition)이라는 아이디어와 대치된다.
- 결론적으로 `static` 키워드를 사용해서는 안된다.

# 느낀점

- 순수한 oop에 불결한 static 메서드가 들어가는 느낌이라고 해야하나. 사실 저자가 결벽증에 가깝다고 생각한다. 타협을 할 생각이 없다. spring을 사용하면 전역 변수와 static 메서드를 사용해야 한다. 그러면 spring은 순수 oop로 만들어진 프레임워크가 아니다. reflection은 전형적으로 oop를 무시하는 로직이다. 캡슐화를 뚫어버리기 때문이다. 하지만 JPA, Jackson 등의 수많은 프레임워크가 reflection을 사용한다. 이 또한 순수한 OOP가 아니다.
- 책은 언어를 초월해서 OOP를 강조한다. Java와 Kotlin을 사용하는 개발자로서 언어가 갖춘 환경을 무시해야하는 순수 OOP를 공감하기 어렵다.
