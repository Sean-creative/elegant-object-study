# 내용 정리

- 모든 클래스는 불변이어야하지만 setter가 있는 객체는 가변 클래스이다.
- getter, setter가 있는 클래스는 클래스가 아니라 자료구조(data structure)이다.

## 객체 대 자료구조

- struct의 경우 멤버에 직접 접근하고 값을 가져오거나 변경할 수 있다.
- 클래스는 어떤 시긍로든 멤버에 직접 접근하는 것을 허용하지 않는다.
    - 메서드를 요청할 때 어떤 방식으로 동작하는지, 어떤 멤버가 작업에 개입하는지 알 수 없다. 이것이 캡슐화(encapsulation)이다.
- 자료구조
    - 투명하다.
    - 글래스 박스(glass box)
    - 수동적
- 객체
    - 불투명
    - 블랙 박스(black box)
    - 능동적
- 객체를 사용하고 자료구조를 사용하지 않는 이유는 유지보수성 때문이다. 프로그래밍은 가시성의 범위를 축소하고 사물을 단순화시켜야 하는 것이다. 특정한 시점에 이해해야 하는 범위가 작을수록 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워진다.
- 데이터는 객체안에 캡슐화되어있고 객체는 살아있다. 객체들은 서로 연결되고 어떤 일을 수행해야 할 때는 메시지를 전송해서 작업을 실행한다. 메시지를 통한 코드의 실행을 메서드 호출(method call)이라고 부른다. OOP에서는 코드가 데이터를 지배하지 않는다. 대신 필요한 시점에 객체가 자신의 코드를 실행시킨다.
- 코드는 OOP에서 부차적인 요소이다. 객체가 일급 시민이며 생성자를 통한 객체 초기화가 곧 소프트웨어이다.
- 객체지향적이고 선언형 스타일을 유지하기 위해서는 데이터를 객체 안에 감추고 절대로 외부에 노출하면 안된다.
- 자료구조 대신 객체를 선택해야 하는 매우 현실적인 이유는 발가벗겨진 데이터가 절차적인 프로그래밍 스타일을 사용하도록 부추기기 떄문이다. OOP에서는 어떤 희생을 치르더라도 절차적인 프로그래밍 스타일을 피해야 한다.

## 좋은 의도, 나쁜 결과

- 근본적으로는 getter와 setter는 캡슐화 원칙을 위반하기 위해 설계되었다.
- C++은 구조체를 포함하고 있어 getter와 setter가 필요하지 않는다.
- getter와 setter는 메서드이기 때문에 데이터가 노출된 것을 아니라고 주장할 수 있지만 사실 getter와 setter는 행동을 정의한 것이 아닌 데이터를 표현하는 로직이다.

## 접두사에 관한 모든 것

- getter/setter 안티 패턴에서 유해한 부분은 접두사인 get과 set 이다.
- 두 접두사는 객체가 진짜 객체가 아니고 자료구조라는 사실을 명확하게 전달한다.
- getDollars()는 “데이터 중에 dollars를 찾은 후 반환하세요”이고 dollars()는 “얼마나 많은 달러가 필요한가요?”라고 묻는 것이다.
- dollars()는 데이터를 노출하지 않지만 getDollars()는 데이터를 노출한다. getDollars()는 메서드를 통해 데이터가 표면에 완전히 드러나 있으며 클래스의 모든 사용자는 이 데이터를 볼 수 있다.
- getter와 setter가 OOP에서 끔찍한 안티 패턴이다. 메서드의 이름을 절대 이런 방식으로 지어서는 안된다.

# 느낀점

- 자바 beans 규약에서는 getter와 setter를 만들어야 한다고 정의 되어있다. 코틀린은 클래스를 정의할 떄 backing field에 대한 getter/setter를 선언에 따라서 자동으로 만들어준다.
- 대체적으로 논리에 대해 상당히 공감한다. 자료구조처럼 사용하지 않고 객체로서 사용하기 위해서이다.
- 우리가 getter setter를 사용해야 하는이유는 명확하지만 반대로 사용해야하지 않은 이유도 명확하게 알 수 있는 챕터였다.
