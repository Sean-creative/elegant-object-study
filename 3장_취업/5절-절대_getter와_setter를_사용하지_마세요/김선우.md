# 간략한 내용정리

@ 죄를 저지르지 말자
- 클래스는 가변성, 잘못된 메서드 이름, 없는 생성자 와 같은 죄를 저지르면 안된다.
- 단순한 자료구조로 사용해서도 안된다.

@ 자료구조
- struct의 경우, struct를 가지고는 어떤 일도 하지 않는다.
- struct와는 아무런 의사소통도 하지 않고 직접적으로 멤버에 접근한다.
- struct는 어떤 '개성'도 지지니 않은 단순한 데이터 가방 일뿐이다.

@ 클래스
- 클래스는 어떤식으로든 멤버에게 접근하는 것을 허용하지 않는다.
- 자신의 멤버를 노출하지도 않고, 우리는 어떤 메소드에 요청만 할뿐이다.
- 어떻게 동작하는지도 알 수 없고, 어떤 멤버가 개입하는지도 알 수 없다. 
- 이것이 바로 캡슐화이고, OOP가 지향하는 가장 중요한 설계 원칙중 하나이다.

@ 자료구조 vs 클래스
- 자료구조는 투명, 글래스박스, 수동적, 죽어있다
- 객체는 불투명, 블랙박스, 능동적, 살아있다

@ 핵심 목표
- 모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다.
- 특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어의 유지보성이 향상되고 이해하고 수정하기도 쉬워진다.
- 사물을 단순화 시키는 가장 좋은 방법은 서브루틴과 데이터 집합을 사용하는 것이다.
- 문장들을 따로 묶어 이름을 붙인 서브루틴을 사용할 수 있다.

@ OOP의 발명
- 코드는 수동적인 존재가 됐지만, 데이터는 능동적인 존재가 되었다.
- 객체 안에 캡슐화되어 있고, 객체는 살아있다. 객체들은 서로 연결되고, 어떤 일을 수행해야 할 때는 메세지를 전송해서 작업을 실행한다.
- 메세지를 통한 코드의 실행을 메서드 호출이라고 한다.
- 객체가 일급 시민이며, 생성자를 통한 객체 초기화가 곧 소프트웨어이다. 소프트웨어는 연산자나 구문이 아닌 생성자를 통해 구성된다.
- 객체지향적이고 선언형 스타일을 유지하기 위해서는, 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안된다.

@ getter, setter
- 근본적으로 getter, setter는 캡슐화 원칙을 위반하기 위해 설계되었다.
- 겉으로는 메서드처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있다는 불쾌한 현실을 가리고 있을 뿐이다.
- 행동이 아닌 데이터를 표현할 뿐이다. (방식이 아니라 -> 이름이 잘못되었다는 것!)
- 접두사도 문제이다. 어떤 존중도 받을 가치가 없는 자료구조라는 사실을 명확하게 전달한다.

@ 정리
- dollars()는 데이터를 노출하지 않지만, getDollars()는 데이터를 노출한다.
- getDollars() 메서드를 통해 데이터가 표면에 완전히 드러나 있으며, 클래스의 모든 사용자는 이 데이터를 볼 수 있다.
- 메서드 이름을 절대 이런 방식으로 지어서는 안된다!!


# 느낀점
- "절대 getter와 setter를 사용하지 마세요" 라는 챕터의 제목만 보면 쉬운 내용이구나 하고 읽다가, 조금 깊은 내용을 다뤘던것 같다.
- 챕터 제목을 "getter와 setter는 나쁜 접두어 입니다" 라고 변경했다면 하는 아쉬움이 있다.
- 읽는 내내 저 메소드를 사용하지 않으면 어떻게 멤버의 값에 접근해야하는가에 대해 의문점을 가져왔는데, 그게 아니라 이름이 잘못되었다는 것이었다...


# 궁금한 점
-

# 찾아봐야 할 것 
-
