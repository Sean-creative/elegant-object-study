# 내용정리

---

> 객체는 자신의 가시성 범위 (scope of visibility) 안에 살아간다.
> 코드의 가독성을 높여 유지보수성을 향상시키는 것에 목표가 있다.

## 1절. -er로_끝나는_이름을_사용하지_마세요

> 클래스는 객체의 팩토리(factory) 이다.

- 클래스는 객체를 인스턴스화한다. (instantiate)
- new 연산자는 단순히 클래스의 인스턴스를 생성할 뿐, 유효성 검증이나 동작 방식도 변경하지 못한다.

- C++ 은 팩토리에서 객체를 제거할 수 있는 delete 연산자를 제공하지만, 많은 언어들은 이를 제공하지 않는다.
- 클래스는 객체의 팩토리이다.
- 클래스는 객체를 만들고, 추적하고, 적절한 시점에 파괴한다.


- Java 언어에서의 팩토리 패턴은 new 연산자를 확장한 것처럼 동작한다.
- 유효성 검증이나, 매개변수를 통한 부가적인 로직을 추가하여 객체를 ₩인스턴스화₩ 한다.
- 필요할 때 겍체를 꺼낼 수 있고, 필요하지 않은 객체는 반환할 수 있는 객체의 웨어하우스 클래스가 될 수 있어야 한다.

> 클래스는 객체의 능동적인 관리자 (active manager) 이다.


### 클래스의 이름을 짓는 적절한 방법

- 잘못된 방법 : 객체의 기능에 기반하여 이름을 짓는 방법
- 옳은 방법 : 클래스가 무엇인지에 기반하여 이름을 짓는 방법

- -er 로 끝나는 수많은 명명의 클래스들 (Controller, Converter, Validator, Encoder, Deeoder ...) 모두 잘못된 명명
- 객체는 행위를 지칭하는 연결장치가 아닌, 대표자 이다.
- 대표자는 스스로 결정을 내릴 수 있고, 행동할 수 있는 자립적인 엔티티이다.


# 느낀점

- 먼저 책의 목표에 적극 동의한다. 코드의 가독성을 높인다는 의미는 유지보수성을 높인다는 의미이며, 이는 비용절감으로 이어진다.
- 그러나, 모든 클래스명을 명명할 때, 일관적인 규칙을 엄격하게 통제했을 때의 얻는 점이 강력할지 의문이 든다.
- 가령, 응집도와 결합도를 높이기 위해, 클래스를 팩토리로 규정하여 ₩대표자₩ 로서 명명하는 대상이 엔티티라 한다면 적극 찬성이다.
- 해당 객체를 살아있는 하나의 객체로 표현하며, 외부에서 어떤 일을 하기 위한 기능들은 모두 그 엔티티 안에 정의되어 있는 엔티티는 대표자라 하기 적합하다.
- 새로운 인스턴스를 생성할 때의 규칙, 특정 매개변수를 받았을 때의 동작과 유효성 검증 등은 객체 내부에서 정의되이 캡슐화가 되어야만 다른 계층에서 사용될 때 일관성 있게 동작할 수 있다.
- 또한 객체의 주요 로직이 내부에 정의되어 있기 때문에, 다른 서비스 계층과의 종속성도 최소한으로 가져올 수 있다.
- 그러한 이점에서, 엔티티 역할을 하는 객체는 대표자로서 명명되고, 구성도 객체로서 이루어져야 한다.

- 그러나 , -er 로 끝나는 수많은 클래스들 (Controller, Converter, Validator, Encoder, Decoder) 등을 모두 ₩대표자₩ 로 정의가 가능한 것일까?
- 특정 데이터 문자열을 Json 형태로 파싱하는 형태도 있을 것이고, 다양한 라이브러리에 따른 행위도 있을 텐데, 이를 모두 ₩대표자₩ 로 정의가 가능한지 의문이다.
- 나는 현재 데이터에 접근 및 변경할 수 있는 로직에 관해서만 ₩대표자₩ 로서 명명하고 객체화하기 때문에, 여전히 ₩행위₩ 에 대한 부분이 잔재되고 있다.
- 책을 읽어가면서 해당 방향에 대해 더 구체적으로 알아가야 할 듯 싶다.

