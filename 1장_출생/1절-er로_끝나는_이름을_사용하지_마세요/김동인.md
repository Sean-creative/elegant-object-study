# 내용 정리

---

- 객체의 가시성 범위를 이해하고 클래스에 적합한 이름을 짓는다.
- 클래스는 객체의 팩토리(factory)이다. 클래스는 객체를 인스턴스(instance)화 합니다.
- Factory 패턴이라는 디자인 패턴과는 다르다. 자바에서는 정적 팩토리 메서드가 이와 같은 역할을 대신한다.
- 클래스는 객체를 만들고 추적하고 적절한 시점에 파괴한다.
- new 연산자와 팩토리 패턴은 개념적으로 동일하다.
- 클래스를 객체의 템플릿으로 설명하는 것은 단순히 필요한 시점에 어딘가에서 복사되는 수동적이고 멍청한 코드 덩어리로 클래스를 격하시킨다.
- **클래스**는 **객체의 팩토리**이다.
- 클래스는 객체의 능동적인 관리자(active manager)이다. 클래스는 객체를 꺼내거나 반환할 수 있는 위치이기 때문에 저장소 혹은 웨어하우스라고 부를 수 있다.
- 앞서 말했든 객체가 생명체이면 클래스는 객체의 어머니에 가깝다.

## 클래스의 이름을 짓는 적절한 방법

**올바른 방법**

- 클래스의 이름은 무엇을 하는지(what he does)가 아니라 무엇인지(what he is)에 기반해야한다.
- 객체는 그의 역량(capability)로 특정지어야 한다. 어떤 사람인지의 특성(attribute)가 아니라 그가 할 수 있는 일(what I can do)로 설명해야 한다.
- 클래스의 객체들이 무엇을 캡슐화할지 관찰하고 이 요소에 붙일 적합한 이름을 찾아야한다.

**잘못된 방법**

- 객체들이 무엇을 하고 있는(doing)지를 보고 기능(function)에 기반해서 이름을 짓는 방법

- 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안된다.
- -er이라는 숨어있는 악마가 있다.
- computer와 user처럼 의미가 변형돤(계산자, 사용자 만의 의미가 아닌) 예외가 있다.
- 객체는 외부 세계와 내부 세계를 이어주는 연결장치(connector)가 아니다.
- 객체는 내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합이 아니다.
- 객체는 캡슐화된 데이터의 대표자(representative)이다.
- 연결장치는 존중받지 못한다. 정보를 수정하거나 스스로 어떤 일을 수행할만큼 충분히 강력하지도 똑똑하지도 못하기 때문에 정보를 전달하기만 하면 됩니다.
- 대표자는 스스로 결정을 내리고 행동할 수 있는 자립적인 엔티티입니다. 객체는 대표자여야 합니다.
- 클래스의 이름이 ‘-er’로 끝난다면 이 클래스의 인스턴스는 실제로는 객체가 아니라 어떤 데이터를 다루는 절차들의 집합일 뿐이다.
- Util이나 Utils라는 의름의 유틸리티 클래스도 좋지 않다.

# 느낀점

---

첫 주제답게 상당히 불편한 내용을 다루고 있다. 실제 실무를 하면서 수만한 -er, -or, 유틸리티 클래스를 많이 접했고 주요 라이브러리에서도 이와 같은 이름을 사용하고 있는 경우가 많다. 쉽게 접할 수 있는 objectMapper, StringUtils, -generator, MyBatis의 mapper 등의 객체들을 봤다.

이들은 다 잘못된 표현인걸까?

위의 내용을 차치하고 생각하면 명확하다. 기능이 아닌, 그 객체가 무엇인지. 기능은 메서드로 표현을 하고 역할에 집중을 하면 된다. 객체지향 사실과 오해에서는 객체는 상태와 행위를 캡슐화하며 다른 객체와의 메시지를 주고 받으며 협력하는 형태로 OOP를 설명한다. 즉, 객체와 객체는 메시지를 주고받는 역할을 할 뿐이지 그 메시지를 연결하는 연결장치로 존재하지 않는다.

다시 돌아와 생각해보면 -er, -or, 유틸리티 클래스는 행위의 초점을 맞추고 그 행위를 수행할 클래스를 만든 것이다. 하지만 행위를 메서드로 돌리고 그 행위를 수행할 주체를 객체로서 명명한다면 그 객체는 역할을 가진 객체이므로 다른 역할을 수행할 수도 있을 것이다.
